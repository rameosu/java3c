# Redis内存淘汰策略和过期键清除策略

## 内存淘汰策略

### Maxmemory配置

`maxmemory`配置指令用于配置Redis存储数据时指定限制的内存大小。通过`redis.conf`可以设置该指令，或者之后使用`CONFIG SET`命令来进行运行时配置。

例如为了配置内存限制为100mb，以下的指令可以放在`redis.conf`文件中。

```xml
maxmemory 100mb
```

设置`maxmemory`为`0`代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB。

当指定的内存限制大小达到时，需要选择不同的行为，也就是**策略**。 Redis可以仅仅对命令返回错误，这将使得内存被使用得更多，或者回收一些旧的数据来使得添加数据时可以避免内存限制。

### 淘汰策略

当maxmemory限制达到的时候，Redis会使用的行为由 Redis的`maxmemory-policy`配置指令来进行配置。

|             策略              |                             描述                             |
| :---------------------------: | :----------------------------------------------------------: |
|         volatile-lru          |    从已设置过期时间的数据集中挑选`最近最少使用`的数据淘汰    |
|         volatile-ttl          |      从已设置过期时间的数据集中挑选`将要过期`的数据淘汰      |
|        volatile-random        |         从已设置过期时间的数据集中`随机选择`数据淘汰         |
|          allkeys-lru          |          从所有数据集中挑选`最近最少使用`的数据淘汰          |
|        allkeys-random         |             从所有数据集中`随机选择`数据进行淘汰             |
|          noeviction           |                  `禁止驱逐`数据（返回错误）                  |
| volatile-lfu（Redis 4.0引入） | 从已设置过期时间的数据集中通过统计访问频率，将`访问频率最少`的键值对淘汰 |
| allkeys-lfu（Redis 4.0引入）  | 从所有数据集中通过统计访问频率，将`访问频率最少`的键值对淘汰 |

## 过期键清除策略

### 过期时间设置

通过expire命令给已存在的key添加过期时间：

```bash
EXPIRE key seconds
```

或者在设置key的时候同步设置：以String类型为例

```bash
 SETEX mykey 60 redis
```

查看key的过期时间：

```
TTL KEY_NAME
```

### 过期时间移除

在超时之前，如果该key被修改，与之关联的超时将被移除。

- persist key 持久化该key，超时时间移除。
- set key newvalue 设置新值，会清除过期时间。
- del key 会清除key和过期时间。
- 例外情况：
  - lpush, zset, incr等操作，在高版本（2.1.3++）之后不会清除过期时间，毕竟修改的不是key本身。
  - rename 也不会清除过期时间，只是改key名字。

### 清除策略

- **事件删除**
  - 每个键都有一个定时器，到期时触发处理事件，在事件中删除。
  - 缺点是需要为每个key维护定时器，key的量大时，cpu消耗较大。

- **惰性删除**
  - 每次访问时才检查，如果没过期，正常返回，否则删除该键并返回空。
- **定期删除**
  - 每隔一段时间，检查所有设置了过期时间的key，删除已过期的键。

Redis采用后两种结合的方式

- 读写一个key时，触发惰性删除策略。
- 惰性删除策略不能及时处理冷数据，因此redis会定期主动淘汰一批已过期的key。
- 内存超过maxmemory时，触发主动清理（内存淘汰策略）。

